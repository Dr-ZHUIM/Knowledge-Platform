import react_lifecycle from '@imgs/article/React/react-hook-lifecycle.png';
import react_timeline from '@imgs/article/React/react-hook-timeline-diagram.png';
export var label = '解析React渲染流程';
export var summary =
  '本文将着重于剖析 React 的渲染是如何进行的，以及分析 Context 与 React-Redux 是如何来影响渲染的。';

# 引用说明

本文参考文章

<p>
<Link
  target="_blank"
  to="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#further-information"
  children="1. Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior
"
></Link>

<br />

<Link
  target="_blank"
  to="https://www.joshwcomeau.com/react/why-react-re-renders/"
  children="2. Why React Re-Renders "
></Link>

<br />

<Link
  target="_blank"
  to="https://julesblom.com/writing/react-hook-component-timeline"
  children="3. Timeline of a React Component With Hooks"
></Link>

<br />

<Link
  target="_blank"
  to="https://wavez.github.io/react-hooks-lifecycle/"
  children="4. React Hooks Lifecycle"
></Link>

</p>

## 解析 React 渲染流程

本文将着重于剖析 React 的渲染是如何进行的，以及分析 Context 与 React-Redux 是如何来影响渲染的。

> 包含版本: React18+

## TOC

## 文章约定

在文章的最前面，这里进行名词的约定：

| 名词                     | 解释                                                                          |
| ------------------------ | ----------------------------------------------------------------------------- |
| 渲染行为                 | 单次的渲染工作，包括 Render Phase 与 Commit Phase                             |
| 渲染队列                 | 多次渲染行为组成的队列，将由 React 同步执行再在同一次重渲染中输出             |
| 渲染函数                 | 函数组件自身 / 类式组件 this.render                                           |
| 渲染函数返回值           | 尚未生成 Fiber 节点的 JSX，同时也是一张渲染快照                               |
| 渲染输出 / React.Element | React 使用 React.createElement 生成的描述 DOM 结构的对象，是 Fiber 节点的来源 |
| Fiber 节点               | 是 Fiber 结构的节点                                                           |
| 重渲染                   | 使用渲染队列输出的值以此更新 UI                                               |

## 什么是 "渲染" ("Rendering") ?

**“渲染”** 是 React 通知组件去生成或更新 UI 的过程，一般会基于 `props` 与 `state` 来维护数据

### 渲染工作概览

<Image src={react_timeline} />

在整个渲染行为流程中，React 会从 组件树的根部 Fiber (the root of Component tree)开始向下遍历去获取**所有被标记为需要更新的**组件。

React 会根据组件的类型，为每一个组件调用渲染函数，同时将其输出值存储以备下个阶段使用

> 函数式组件调用自己 `FunctionComponent(props)`  
> 类式组件调用实例上的 render 方法 `classComponentInstance.render()`

组件的渲染输出一般用 JSX 语法来编写，**Babel** 会帮助你自动的调用 `React.createElement()` 方法来创建 `React elements`。

> 组件的渲染输出值就是 `React elements`，是一类用以描述 UI 结构的对象

如下是如何创建 `React elements` 的过程

```tsx
/**
 * 组件创建 React elements
 */
// jsx 语法编写的渲染函数返回值
return (
  <SthToRender title="something" name="some">
    Whatever here
  </SthToRender>
);

// babel编译后 ---->
return React.createElement(
  SthToRender,
  { title: 'something', name: 'some' },
  'Whatever here',
);

// React.createElement方法会返回如下的对象
{type: SthToRender, props: {title: 'something', name: 'some'}, children: ['Text Here']}

// React内部调用SthToRender，进一步渲染
let elements = SthToRender({...props, children})


/**
 * HTML节点创建 React elements
 */
return <button onClick={() => {}}>Click Me</button>

// babel编译后 ---->
React.createElement("button", {onClick}, "Click Me")

// React.createElement方法会返回如下的对象
{type: "button", props: {onClick}, children: ["Click me"]}

```

当 React 收集了整棵组件树的渲染返回值后， React 将比对新旧两颗树的对象，以收集被标记需要更新的节点。

这个比对 (diffing) 与计算的过程被称为 协调 `reconciliation`

然后 React 会在一个同步的序列中将所有计算出的结果应用到 DOM 上

### 渲染阶段与提交阶段 (Render and Commit Phases)

React 将 渲染工作 分为两个阶段 渲染阶段与提交阶段 (Render and Commit Phases)

> - 渲染阶段 负责渲染组件，**初始化或更新非副作用 hooks**，生成 React Elements， 然后计算变化
> - 提交阶段 负责将变化呈现在 DOM 上

<Image src={react_lifecycle} />

在 React 将 DOM 更新后，React 会将<Mark>所有的指向 DOM 节点或者组件实例</Mark>的`ref` 更新。

在这之后，React 会同步的执行 类式组件的生命周期函数 `componentDidMount` 与 `componentDidUpdate`， 以及函数式组件的 `useLayoutEffect` hooks

接着 DOM 会根据 提交阶段 提供的节点绘制页面

最终 React 就会设置一个短暂的定时器，在定时器到期时，执行所有的 `useEffect` hooks<Sup title="Passive Effects Phase">注</Sup>.

> 这个过程也被称为 `Passive Effects Phase`,
> 这也是为什么 `useEffect` 会在组件**初次渲染**时会默认执行一次回调函数的原因,
> 倘若**没有提供依赖数组**，`useEffect` 的回调函数会不断在组件更新阶段被执行

理解 渲染行为 的关键就是: **渲染不等于更新 DOM**，组件渲染有可能不会有任何的可视区域的变更。

比如:

```tsx
//parent Component

function ParentComponent() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount((v) => v + 1)}> +1 </button>
      <ChildrenComponent />
    </div>
  );
}

// child Component

function ChildComponent() {
  // return node
}
```

当点击按钮触发渲染时，由于父组件进行了更新渲染，子组件也不得不进行渲染，**即使没有任何 DOM 变化**

在 React 18 版本，React 添加了 并发渲染 (concurrent render) 的一些 API，比如说 <Link className="inline" target="_blank" to="https://react.dev/reference/react/useTransition#usetransition" children="useTransition"></Link>

它给予 React 暂停 渲染阶段 的工作，来让浏览器去处理事件，React 随之会暂停，直到浏览器返回可使用时间超过阈值时，再继续工作。

也就是说，在如下两种情况，React 的 渲染行为不会更新 DOM

1. 组件返回了相同的渲染输出值<Sup title="即 React Element">注</Sup>，因此没有变化。
2. 在 并发渲染模式 下，React 可能会终止渲染一个组件数次，但在其他的组件更新导致 React 判定现在的工作已完成的情况下，仍会抛出渲染输出值。

## React 如何处理渲染？

### 渲染队列

在初始化渲染结束后，React 能够使用一些不同的方法来排列 更新渲染

- 函数式组件
  - `useState` setters <Sup title="即useState返回的第二个值">注</Sup>
  - `useReducer` dispatches
- 类式组件
  - `this.setState()`
  - `this.forceUpdate()`
- 其他方式
  - 重新调用根组件的 `render<App>` 方法 <Sup title="相当与在根组件调用forceUpdate()">注</Sup>
  - 使用 `useSyncExternalStore` hook 中的触发器

**小技巧：**

> 尽管 函数式组件 没有 `forceUpdate` 方法，但是我们能通过 `useReducer` 来实现强制更新

```tsx
const [, forceRender] = useReducer((c) => c + 1, 0);
```

### 默认渲染行为

**React 的默认渲染行为就是：父组件渲染，React 将深遍历并渲染其所有的子组件**

一如我在上面写的案例：

```tsx
//parent Component

function ParentComponent() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount((v) => v + 1)}> +1 </button>
      <ChildrenComponent />
    </div>
  );
}

// child Component

function ChildComponent() {
  // return node
}
```

简单来说，在默认渲染情况下，React 不会因 “Props 更新” 这一行为而重渲染子组件，是因为父组件重渲染了，所以才重渲染子组件

举个极端的例子：在根组件中调用 setState，会导致整个 React 应用重新渲染，尽管大多数组件都不会更新 DOM，但是 React 仍然要处理他们的渲染，以确保 DOM 不需要更新。

也就是说：

**React 是通过渲染来知道是否需要更新 DOM 的**

### React 渲染的规则

对于 React 的渲染来说，最重要的就是 渲染**必须是纯函数，没有任何副作用**

> 在 React 中副作用极有可能会导致额外的渲染，所以在渲染中产生副作用有可能会导致死循环，也有可能导致丢失变量。  
> 在函数式组件内，**最高级作用域必须保证是纯函数**，hooks 则根据自己的规则来调整。  
> 下面是类式组件的方法清单，可以大致的看一下。

```tsx
class MyComponent extends React.Component {
  constructor() {
    // pure
  }

  static getDerivedStateFromProps() {
    // pure
  }

  shouldComponentUpdate() {
    // pure
  }
  componentDidMount() {
    // not pure
  }
  componentDidUpdate() {
    // not pure
  }
  componentWillUnmount() {
    // not pure
  }
  handleClick = () => {
    // not pure
  };
  render() {
    // pure
    return <div onClick={this.handleClick} />;
  }
}
```

- 渲染逻辑内不应当出现的
  - 不要尝试在下一次渲染时修改一般初始化的变量
  - 不要创建随机值，比如 `Math.random()` 或者 `Date.now()`
  - 不要创建网络请求<Sup title="网络请求的结果不可预测，请在hooks或者生命周期钩子里处理他们，使他们的结果产生渲染，而不是称为渲染的一部分">注</Sup>
  - 不要更新 state<Sup title="会死循环的">注</Sup>
- 渲染逻辑内可以出现的
  - 修改在渲染中刚刚创建的变量
  - 抛出错误
  - "Lazy initialize" 懒初始化还没被创建的数据，相当于一个**被缓存在模块**<Sup title="模块被读取的时候会执行一次">注</Sup>中的值

可能会对 一般初始化 和 懒初始化 产生疑惑，此处补充以下两种不借助 hooks 定义值的方法

1. 一般初始化

一般初始化 将变量初始化在组件内，也就是在渲染内初始化,这也意味着每一次渲染都会将这个值重新定义，而渲染结束这个值会**被存储在渲染快照中，无法修改**。

```tsx
// 一般初始化
function MyComponent() {
  const a = 123;
}
```

2. 懒初始化

懒初始化 将变量初始化在顶级作用域内，也就是模块内，只有启动应用的时候这个值才会被初始化，相当于缓存了一个值。

```tsx
// 懒初始化
var cache = new Map();
function MyComponent(props) {
  if (!cache.has(props.id)) {
    cache.set(props.id, function () {});
  }
  return cache.get(props.id);
}
```

### 组件的 Metadata 与 Fibers

React 存储了一种内部的数据结构来追溯所有的存在的组件实例，
这种数据结构的核心是一种被称为 "fiber" 的对象，这种架构被称为 "Fiber" 架构(注意有大写)

对 fiber 的简单学习也可以参考该文章<Link target="_blank" to="https://pomb.us/build-your-own-react/">build-your-own-react</Link>

fiber 对象中存储了一系列的属性，一如：

- 节点的组件类型
- 节点当前的 props 与 State
- 指向节点的 parent,sibling,child 组件的指针
- 以及一系列其他用于追溯渲染进程的属性

这里提供一下缩减版本的 fiber 类型：

```ts
export type Fiber = {
  // tag 用于定义fiber的类型
  tag: WorkTag;

  // 每个fiber 的唯一key
  key: null | string;

  // 用于处理该fiber节点是函数式组件还是类式组件.
  type: any;

  // Fiber架构核心，用于递归fiber tree.
  child: Fiber | null;
  sibling: Fiber | null;
  index: number;

  // props
  pendingProps: any;
  memoizedProps: any; // 用于创建React.Element的props

  // state与callback更新的队列.
  updateQueue: Array<State | StateUpdaters>;

  // 用于创建React.Element的state
  memoizedState: any;

  // 这个fiber依赖的上下文或者事件
  dependencies: Dependencies | null;
};
```

在渲染行为的渲染阶段期间，React 会遍历 fiber 树，然后创建一个更新后的树作为渲染的结果。

fiber 对象会存储组件中实际的 props 与 state 的值，也就是说当调用这些值的时候，React 实际上是给予了获取存储在 fiber 中的值

而在类式组件中，`this.props` 也的确被定义，不过 React 会将这里的值复制到组件对应的 fiber 中，因此调用的仍是 fiber 中的值。

换句话说：组件与 fiber 是同一个东西，组件是给程序员使用的，fiber 是给 React 使用的。

### 组件的 Type 与 协调 (Reconciliation)

React 为了尽可能的有效地重渲染，会最大程度的复用已经存在的组件树与 DOM 结构。

倘若在要求 React 更新在组件树上的同一个位置的统一类型的组件，React 会仅仅采用更新而不会重新创建一个节点。

> React 会将渲染过的组件实例保存下来。

那么 React 是怎么知道何时或者什么被改变了呢？

React 会先使用 `===` 比较节点的 type, 如果一个在指定位置的节点被修改为另一个 type，比如说 `<div>` to `<span>`,
React 会假设整棵组件树已经被修改从而加速比较过程。然后，React 将**摧毁该组件存在的组件树部分，包括所有 DOM 节点**，最终重建一棵组件树。

这意味着**不要在渲染的时候创建新的组件类型！**，对于 React 来说，当开发者创建了一个新的组件类型，就会导致它摧毁并重建子组件树。

也就说以下的行为是性能低下的：

```tsx
function ParentComponent() {
  function ChildComponent() {
    return <div>Hi</div>;
  }

  return <ChildComponent />;
}
```

对于组件 `ParentComponent` 来说，每一次都会创建新的组件类型 `ChildComponent`,React 将无法保存该组件，从而重复重建子组件树的过程

所以，要记得分开定义组件

```tsx
function ChildComponent() {
  return <div>Hi</div>;
}

function ParentComponent() {
  return <ChildComponent />;
}
```

### Keys 与 协调 (Reconciliation)

React 借助 `key` 这一 pseudo-prop<Sup title="虚假属性">注</Sup>, 以此来区分同一种组件的不同实例，每一个 `key` **对于这个组件类型来说**都应当是独一无二的。

应当注意的是 `key` **不是一个真实的属性**，对 React 来说，`key` 只是一个提醒用的属性，会将其消除，因此**开发者无法获取它**。

一般在基于数组渲染数据时，为被遍历渲染的组件添加 `key`, 应当注意的是**最好不要使用 index 来作为 key，特别是你的功能涉及到排序、删除的时候。**

```tsx
// ✅ 使用你的数据ID作为key是很好的选择
return <>{todos.map(todo => <TodoListItem key={todo.id} {...todo} />) }</TodoListItem>
```

举个为什么不要使用 `index` 作为 `key` 的例子:

以下这段代码提供了一个循环渲染 input 的案例，有两个按钮，一个负责切换 key，一个负责反转数组。

```tsx
const items = [
  { id: '00001', todo: '00001' },
  { id: '00002', todo: '00002' },
  { id: '00003', todo: '00003' },
];

function KeyExample() {
  const [todos, setTodos] = useState(items);
  const [mode, setMode] = useState<'IndexMode' | 'IdMode'>('IndexMode');

  const handleReverse = useCallback(() => {
    setTodos((v) => [...v.reverse()]);
  }, [todos]);

  return (
    <Demo>
      <h4>{mode}</h4>
      <div className="flex gap-5 mt-5 mb-5">
        <button
          className="btn btn-primary"
          onClick={() =>
            setMode((v) => (v === 'IndexMode' ? 'IdMode' : 'IndexMode'))
          }
        >
          切换至{mode === 'IndexMode' ? 'IdMode' : 'IndexMode'}
        </button>
        <button className="btn btn-primary" onClick={handleReverse}>
          反转数组
        </button>
      </div>
      {todos.map((todo, index) => (
        <div
          className="flex gap-5 mt-5 mb-5"
          key={mode === 'IdMode' ? todo.id : index}
        >
          todo: {todo.todo}
          <input
            className="pl-5 pr-5 border-solid border-[1px] border-black"
            type="text"
          />
        </div>
      ))}
    </Demo>
  );
}
```

这个案例，我们可以观测三个行为：

1. 当 key 为 index 时,反转数组时 input 没有反转
2. 切换 key 时，组件的 key 被修改，组件重新渲染
3. 当 key 为 id 时，反转数组时，input 反转

这是因为 **React 在组件的 props 没有改变的时候，会比较 Key 是否有被修改**。

当 key 为 index，反转数组不会导致响应位置的 key 被修改，同时 input 的 props 也没有变，因此 React 认为这里是同一个组件

切换 key 时，所有组件的 key 被修改，所有组件重新渲染。

当 key 为 id 时，反转数组会导致组件的 key 被修改，input 作为组件的一部分，将会被重新渲染

也就是说，**key 的修改会导致组件重新渲染**，开发者可以通过为组件绑定一个 key，然后通过改变这个 key 而重新渲染这个组件。

<KeyExample />

### 批处理 (Batching) 与 不同 React 版本批处理出现的时机

默认情况下，每进行一次 `setState` 都会导致 React 开始一次新的渲染队列，同步的执行渲染行为，最终进行重渲染。

然而，React 在内部也应用了一种渲染队列优化手段 —— 批处理。

批处理是指 React 会将复数的**同步的**渲染请求组装成单次重渲染，以此获取更好的渲染表现。

> 在 React 17- 的版本中，批处理有两个特性：
>
> 1. 只会在 Event Handler 中使用，即点击或者其他的事件中使用
> 2. 当同步的渲染请求被异步行为中断后，其余的渲染请求将不被批处理

在如下的案例中，React 17- 会重渲染三次，而 React 18+ 则是两次

```tsx
const [counter, setCounter] = useState(0);

const onClick = async () => {
  setCounter(0);
  setCounter(1);

  const data = await fetchSomeData();

  setCounter(2);
  setCounter(3);
};
```

React 17-:

1. setCount(0) --- setCount(1) 批处理
2. 被异步行为中断，React 认为同步请求栈已经处理完毕，其余的渲染请求将不被批处理
3. setCount(2)
4. setCount(3)

React 18+:

1. setCount(0) --- setCount(1) 批处理
2. 被异步行为中断
3. setCount(2) --- setCount(3) 批处理

### “异步”渲染，闭包与 State 快照

当开发者刚刚开始学习 React 时，总会犯下这样的错误：

在尝试更新了 state 后，想要立即使用调用被修改的值，却只能获取到上一次重渲染时存储的 state 的值

```tsx
//...function definition

const [counter, setCounter] = useState(0);

const handleClick = () => {
  setCounter(counter + 1);
  // 获取的值是0
  console.log(counter);
};

//...other codes
```

同时还有这样的错误：

重复调用 n 次 `setCounter(counter + 1)` ，却发现最终结果只加了 1，而不是 n

```tsx
//...function definition

const [counter, setCounter] = useState(0);

const handleClick = () => {
  setCounter(counter + 1);
  setCounter(counter + 1);
  setCounter(counter + 1);
  setCounter(counter + 1);
};

// 点击一次div，counter只会加1
return <div onClick={handleClick}>{counter}</div>;
```

这是为什么呢？

接下来本文将从两个层面来解释这个问题，理念层 —— State Snapshot —— 实现层 闭包函数 Event Handler

#### State 快照

> State 变量不像你在 JS 中可以读写的变量，它表现地更像一个快照。setState 不会修改开发者已经维护好的 state，而是会触发一次重渲染 —— React 官方

开发者调用的 state 实际上并没有维护在组件中，state 维护在 React 内部， 当 React 调用了开发者的渲染函数, 渲染函数返回的 JSX 就像 UI 当前所有 state 的快照。它的 props，Event Handler 以及 内部变量都会使用这个快照里的 state 进行运算。

React 重渲染 一个组件时的流程如下：

1. React 调用 渲染函数
2. 渲染函数返回 JSX，生成 state 的渲染快照
3. React 更新 UI 以匹配快照

也就是说，开发者调用的 state 的值就是上次渲染中 state 的渲染快照，**state 只会在重渲染的时候被更新**

从这个角度来说上面两个案例的问题就是：

在同一次的渲染结果中调用的 state 的值都是这个 state 的上一次的渲染快照，在没有渲染完成前都不会被改变。

#### State “异步” 更新 与 EventHandler 的闭包

社区中对于 State 更新的广为流传的说法是：React state 更新是异步的

但是，严格来说，React 渲染行为是同步的，React state 的更新会在 React 工作循环的相当尾部的部分在一个“微任务”中被执行。

因此实际上讨论的异步并不是程序意义上的异步，而是指 **setState 后是否立刻进行渲染行为**

那么 React 是如何做到开发者的 EventHandler 只能访问上次渲染的 state 的渲染快照的呢？

原来在 React 里， 开发者的 EventHandler 是闭包函数，**它只能访问在函数建立时的变量**，也就是说当前的 EventHandler 只能访问上一次的 state 的渲染快照，而当开发者多次调用同一个 state 的 setState 时，
这些被触发的渲染行为都被压入渲染栈中，它们被批处理后的渲染函数返回值中的 state 渲染快照会用于生成下一个 EventHandler。

这也就实现了：在同一次的渲染结果中调用的 state 的值都是这个 state 的上一次的渲染快照，在没有渲染完成前都不会被改变。

### 提交阶段的生命周期

事实上在渲染行为的提交阶段中的生命周期函数<Sup title="比如componentDidMount, componentDidUpdate以及useLayoutEffect">注</Sup>有一些额外的作用，
这些函数允许开发者在 React 返回新的渲染数据之后，浏览器重绘之前来处理逻辑。

**即触发用户感知不到的行为**

举一个例子：

- 首次渲染某个 state 没有计算准确的组件(<Link target="\_blank" to="https://react.dev/reference/react/useLayoutEffect#measuring-layout-before-the-browser-repaints-the-screen">ToolTip </Link> 就是一个典型的例子)
- 测量 DOM 节点的尺寸以此修改组件的位置
- 基于测量，修正 state
- 立即使用更新的数据重渲染

React 会将这两次渲染在提交阶段的生命周期中**同步地**执行，因此用户看到的就是修正过后重渲染的组件。

---

## 增强渲染性能

尽管渲染对于 React 生态来说是理所应当的，但是过度的渲染导致的性能浪费也是要关注的。如果一个组件的渲染输出没有改变，DOM 结构也就不会更新，那么这个组件就
进行了不必要的渲染。

**React 组件的渲染输出应当完全基于当前的 props 与当前的 state**，也就是说，当我们确认该组件在父级组件多次渲染后，渲染输出仍然保持不变时，我们就确认可以
对它的渲染进行优化了。

在程序界，优化程序有两种手段：1. 提高程序速度 2. 降低调用次数

那么在 React 组件渲染这方面，我们使用第二种：在不必要的情况下，不渲染组件

### 组件 渲染优化 技术

React 提供了三个主要允许开发者跳过渲染的 API, `React.memo()`,`React.component.shouldComponentUpdate()`,`React.PureComponent`;

比较重要的是 `React.memo()`，它能够接受一个组件，然后返回一个被包裹的 HOC 组件，函数式组件和类式组件都可以使用这个 API。

```tsx
function MyComponent({ num }: { num: number }) {
  return <div>{num}</div>;
}
export default React.memo(MyComponent);
```

这个组件会监听 props 是否有被改变，如果没有，就会避免进行重渲染。

### 新的 props 引用 是如何影响 渲染优化 的

### 优化 props 引用

### 如何合理使用缓存 (useMemo, useCallback, memo)

### 不可更改性 与 重新渲染

### 测量 React 组件渲染性能

---

## Context 与 渲染行为的扩展能力

### 有关 Context 的基础

### 更新 Context 的值

### Context 中的 State 更新导致的重新渲染行为

### Context 更新 与 渲染优化

---

## React-Redux 与 渲染行为

### React-Redux 订阅流程

### connect 与 useSelector 的区别

---

## 将来 React 的 改进方向

### `React Forget` 缓存

### Context 选择器

---

## 总结
