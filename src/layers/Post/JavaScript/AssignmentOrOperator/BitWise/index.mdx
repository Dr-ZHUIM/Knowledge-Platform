# BitWise ------ 位运算

## 知识前提

JS 储存 Number 类型数据采用的是双精度储存(64 位)。

位运算时会先将数据转为 32 位二进制整数，超过 32 位的数字会丢弃其最高有效位，然后进行正负运算，最终执行补码操作

> 计算机储存整数需要补码操作，因为 CPU 只有加法运算器
>
> > 补码操作：正数的补码为自身，负数的补码为自身的反码+1

---

### 1.按位与 `&`

按位与 `&` 会将两个操作数的二进制补码进行相应位配对操作

> 即 同一位的值都为 1 时,这一位为 1

举个例子 `5 & 10`

```js
// 5
// 0000 0000 0000 0000 0000 0000 0000 0101

// 10
// 0000 0000 0000 0000 0000 0000 0000 1010

// 5 & 10

// 0000 0000 0000 0000 0000 0000 0000 0101
// NNNN NNNN NNNN NNNN NNNN NNNN NNNN NNNN
// 0000 0000 0000 0000 0000 0000 0000 1010

// |
// V

// 0
// 0000 0000 0000 0000 0000 0000 0000 0000
```

<BitWiseDemo title="按位与" operator="&" />

---

### 2.按位或 `|`

按位与 `&` 会将两个操作数的二进制补码进行相应位配对操作

> 即 当相应位的任一值为 1 时,这一位为 1

举个例子 `5 & 10`

```js
// 5
// 0000 0000 0000 0000 0000 0000 0000 0101

// 10
// 0000 0000 0000 0000 0000 0000 0000 1010

// 5 & 10

// 0000 0000 0000 0000 0000 0000 0000 0101
// NNNN NNNN NNNN NNNN NNNN NNNN NNNN YYYY
// 0000 0000 0000 0000 0000 0000 0000 1010

// |
// V

// 0
// 0000 0000 0000 0000 0000 0000 0000 1111
```

<BitWiseDemo title="按位或" operator="|" />

#### 应用场景

##### **1. 取整**

**前提 1 :** 位运算时会先将数据转为 32 位二进制整数，超过 32 位的数字会丢弃其最高有效位

**前提 2 :** 任何数与数字 0 进行按位或的操作都会返回原来的数字

```js
// 5
// 0000 0000 0000 0000 0000 0000 0000 0101

// 0
// 0000 0000 0000 0000 0000 0000 0000 0000

// 5 | 0

// 0000 0000 0000 0000 0000 0000 0000 0101
// NNNN NNNN NNNN NNNN NNNN NNNN NNNN NYNY
// 0000 0000 0000 0000 0000 0000 0000 0000

// |
// V

// 0
// 0000 0000 0000 0000 0000 0000 0000 0101
```

**结论 :** `n | 0 = n`

---

### 3.按位异或 `^`

按位与 `&` 会将两个操作数的二进制补码进行相应位配对操作

> 即 当相应位的两个操作数相同时，这一位为 0

举个例子 `5 ^ 11`

```js
// 5
// 0000 0000 0000 0000 0000 0000 0000 0101

// 10
// 0000 0000 0000 0000 0000 0000 0000 1010

// 5 ^ 10

// 0000 0000 0000 0000 0000 0000 0000 0101
// NNNN NNNN NNNN NNNN NNNN NNNN NNNN YYYN
// 0000 0000 0000 0000 0000 0000 0000 1011

// |
// V

// 0
// 0000 0000 0000 0000 0000 0000 0000 1110
```

<BitWiseDemo title="按位异或" operator="^" />

#### 应用场景

##### **不借助第三个变量交换变量的值**

**前提 1 :** 两个相同的数进行按位异或运算返回 0

**前提 2 :** 任意数与数字 0 进行按位异或运算返回原来的数

现在一起来看一下交换变量的方法。

```ts
let num1 = 5;
let num2 = 10;
// 方法1： 借助第三个变量；
function thirdArgument(num1: number, num2: number) {
  let _num1 = num1;
  let _num2 = num2;
  let num3 = _num1;
  _num1 = _num2;
  _num2 = num3;
  return { num1: _num1, num2: _num2 };
}

// 方法2： 数组解构赋值
function Destructuring(num1: number, num2: number) {
  let _num1 = num1;
  let _num2 = num2;
  [_num1, _num2] = [_num2, _num1];
  return { num1: _num1, num2: _num2 };
}

// 方法3：按位异或运算
function XOr()(num1: number, num2: number) {
  let _num1 = num1;
  let _num2 = num2;
  _num1 = _num1 ^ _num2;
  // _num2 = (_num1 ^ _num2) ^ _num2 = _num1 ^ ( _num2 ^ _num2 ) = _num1 ^ 0 = _num1;
  _num2 = _num1 ^ _num2;
  // _num1 = (_num1 ^ _num2) & _num1 = ( _num1 ^ _num1 ) ^ _num2 = 0 ^ _num2 = 0;
  _num1 = _num1 ^ _num2;
  return { num1: _num1, num2: _num2 };
}
```

**结论：** 按位异或运算可以用于消元

**延伸用法：** 寻找数组中唯一的数

假设有一数组，其中的有一个数是单独的，其他的数两两相对，请返回唯一的数。

```ts
function findUnique(arr: number[]) {
  return arr.reduce((pre, cur) => pre ^ cur);
}
```

---

### 4.按位非 `~`

按位非 `~` 会将二进制补码数据的每一位进行取反操作

> 即 0 -> 1; 1 -> 0

举个例子 `~10`

```js
// 0000 0000 0000 0000 0000 0000 0000 1010

// 10 取反 -> -11

// 1111 1111 1111 1111 1111 1111 1111 0101
```

根据知识前提，我们知道负数的补码为自身的反码 + 1,也就是说对数字 n 进行补码取反意味着返回 - n - 1

<BitWiseDemo title="按位非取反" operatorSelf="~" />

#### 应用场景

##### **取整**

**前提 :** 位运算时会先将数据转为 32 位二进制整数，超过 32 位的数字会丢弃其最高有效位

那么我们连续对数字 `n` 执行两次按位非操作的过程就是

```js
// 1. 将数字 n 取整

// 2. 按位非 ---> - n - 1

// 3. 第二次按位非 ---> - (- n - 1) - 1 --> n + 1 - 1 ---> n  ---> 获得整数n
```

**结论 :** `~~n` 在 `n >= 0` 的情况下与 `Math.floor(n)` 相当, 在 `n <= 0` 的情况下与 `Math.round(n)` 相当

<BitWiseDemo title="按位非向下取整" operatorSelf="~~" />

---

##### **2. indexOf 场景**

**前提 1:** String.prototype.indexOf 方法会根据字符串中某个字符的存在情况而返回 `-1` 或者 一个 索引值。

> Array.prototype.indexOf 方法则是根据数组中某个元素的存在情况而返回 `-1` 或者 一个 索引值。

**前提 2:** `Boolean(-1) === true` , `Boolean(0) === false`。

**前提 3:** `~n = - n - 1`。

**结论 :**

在字符**存在**于字符串中的情况下即 `index >= 0` 时， `~index <= -1`; 而字符**不存在**的情况下即 `index === -1`时， `~index = 0`;

根据我们的前提 2，我们可以将 `~index` 作为布尔值来构建条件式, 即

```js
if (~index) {
  // your condition here ...
}
```

现在我们来看以下的案例：

```js
const str = "I'm a string here!";
const strIndex = str.indexOf('string');

// Yeah! We find the string! It's index is 6!
if (strIndex >= 0) {
  console.log(`Yeah! We find the string! It's index is ${strIndex}!`);
} else {
  console.log('No string was found!');
}
```

这是一个经典的使用 indexOf 的案例,通过 `indexOf` 的返回值是否大于等于 0 来构建条件式。我们可以根据结论来进行改造：

```js
const str = "I'm a string here!";
const strIndex = str.indexOf('string');

// Yeah! We find the string! It's index is 6!
if (~strIndex) {
  console.log(`Yeah! We find the string! It's index is ${strIndex}!`);
} else {
  console.log('No string was found!');
}
```

---

### 5.左移 `<<`

左移 `<<` 将 32 位二进制向左移动指定的位数，空缺的位将会使用 0 填充。左移不会影响符号位。

> `n << y = n * 2 ** y`

举个例子 `5 << 3`

```js
// 0000 0000 0000 0000 0000 0000 0000 0101

// 5 << 3 = 5 * 2 ** 3 = 40

// 0000 0000 0000 0000 0000 0000 0010 1000
```

<BitWiseDemo title="左移" operator="<<" />

---

### 6.有符号右移 `>>`

有符号右移 `>>` 将 32 位二进制向右移动指定的位数，空缺的位将会使用最左侧的符号位填充。有符号右移不会影响符号位。

> `n >> y = Math.floor(n / 2 ** y)`

举个例子 `-9 >> 2`

```js
// 1111 1111 1111 1111 1111 1111 1111 0111

// -9 >> 2 = Math.floor(-9 / 2 ** 2) = -3

// 1111 1111 1111 1111 1111 1111 1111 0111
```

<BitWiseDemo title="有符号右移" operator=">>" />

---

### 6.无符号右移 `>>>`

无符号右移 `>>>` 将 32 位二进制向右移动指定的位数，空缺的位将会 0 填充。有符号右移会影响符号位，**符号位始终为 0，即为正数**。

无符号右移 `>>>` 会对负数产生较大影响，对正数来说它与有符号右移 `>>` 一直

举个例子 `-9 >>> 2`

```js
// 1111 1111 1111 1111 1111 1111 1111 0111

// -9 >> 2 = 1073741821

// 0011 1111 1111 1111 1111 1111 1111 0111
```

<BitWiseDemo title="无符号右移" operator=">>>" />
