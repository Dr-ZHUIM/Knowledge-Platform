export var label = '从事件循环到任务队列再到Promise';
export var summary = `JavaScript 中存在很多异步操作,Promise 将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。可以通过链式调用多个 Promise 达到我们的目的。
Promise 在各种开源库中已经实现，现在标准化后被浏览器默认支持。
promise 是一个拥有 then 方法的对象或函数`;

# Promise

## 知识前提

### 事件循环

默认情况下，浏览器的每个 tab 对应一个渲染进程，渲染进程包含主线程、合成线程、IO 线程等多个线程。

主线程的任务繁忙，需要处理 DOM、计算样式、处理布局、处理事件响应、执行 JS 代码等任务

其他进程通过 IPC 将任务发送到渲染进程的 I/O 进程，然后 I/O 进程将任务发送到主线程的任务队列

根据队列**先进先出**的特性，最先加入队列的任务将被优先处理。

除去任务队列，浏览器按章 WHATWG 标准实现了延迟队列，用于存放延迟执行的任务

当本轮循环任务执行后，浏览器检查是否有延迟任务过期，如有任务过期，则执行该延迟任务

接下来一起看一段伪代码，我们将任务队列中正常执行的任务称为 `processTask`, 延迟队列中的任务称为 `processDelayTask`

```js
function MainThread() {
  while (true) {
    const task = taskQueue.takeTask();
    processTask(task);
    processDelayTask();
    if (!keepRunning) {
      break;
    }
  }
}
```

可以注意到延迟任务在任务的后面执行，这意味着**如果任务的执行事件过长会导致延迟任务无法正常按期执行**

看个案例：

```js
function sayHello() {
  console.log('hello');
}
function test() {
  setTimeout(sayHello, 0);
  for (let i = 0; i < 5000; i++) {
    console.log(i);
  }
}
test();
```

即使定时器的延迟只有 0，也需要等待 test 所在的任务执行完后才能执行，因此 sayHello 的最终延迟时间是比设定时间大的。

#### 宏任务与微任务

在上节，可以发现加入任务队列的新任务由于队列的特性**先入先出**必须等待队列中其他任务执行完毕才能执行，这将难以处理突发的优先级任务。

在任务队列中的任务<Sup title="任务与延迟任务">注</Sup>被称为宏任务(Tasks)，为了解决时效性问题，宏任务执行过程中可以产生微任务(MicroTasks)，并保存在该宏任务执行上下文的微任务队列中，
在宏任务执行结束前，线程会遍历其微任务队列，将微任务批量执行。

本文的核心主体 Promise 属于微任务

---

## Promise 构建函数

---

## Promise.then

---

## Promise.catch

---

## Promise.finally

---

## Promise.all

---
